/**
                                    ‚£Ä‚°†‚¢§‚°Ä          
                                 ‚¢Ä‚°¥‚†ü‚†É  ‚†ô‚£Ñ         
                                ‚£†‚†ã      ‚†ò‚£Ü        
                              ‚¢†‚†æ‚¢õ‚†í       ‚¢∏‚°Ü       
                              ‚£ø‚£∂‚£Ñ‚°à‚†ì‚¢Ñ‚††‚°Ä   ‚£Ñ‚£∑       
                             ‚¢Ä‚£ø‚£∑ ‚†à‚†±‚°Ñ‚†ë‚£å‚†Ü  ‚°ú‚¢ª       
                             ‚¢∏‚£ø‚°ø‚†≥‚°Ü‚†ê‚¢ø‚£Ü‚†à‚¢ø  ‚°á‚†ò‚°Ü      
                              ‚¢ø‚£ø‚£∑‚°á  ‚†à‚¢Ü‚†à‚†Ü‚¢∏  ‚¢£      
                              ‚†ò‚£ø‚£ø‚£ø‚£ß  ‚†à‚¢Ç ‚°á  ‚¢®‚†ì‚£Ñ    
                               ‚£∏‚£ø‚£ø‚£ø‚£¶‚£§‚†ñ‚°è‚°∏ ‚£Ä‚°¥‚†ã ‚†à‚†¢‚°Ä  
                             ‚¢†‚£æ‚†Å‚£π‚£ø‚£ø‚£ø‚£∑‚£æ‚†Ω‚†ñ‚†ä‚¢π‚£Ä‚†Ñ   ‚†à‚¢£‚°Ä
                             ‚°ü‚£á‚£∞‚¢´‚¢ª‚¢â‚†â ‚£ø‚°Ü  ‚°∏‚°è      ‚¢á
                            ‚¢®‚°á‚°á‚†à‚¢∏‚¢∏‚¢∏  ‚°á‚°á  ‚†Å‚†ª‚°Ñ‚°†‚†Ç   ‚†ò
‚¢§‚£Ñ                         ‚¢†‚†õ‚†ì‚°á ‚†∏‚°Ü‚¢∏ ‚¢†‚£ø    ‚£∞‚£ø‚£µ‚°Ü    
‚†à‚¢ª‚£∑‚£¶‚£Ä                     ‚£†‚°ø‚£¶‚£Ä‚°á ‚¢ß‚°á  ‚¢∫‚°ü   ‚¢∞‚†â‚£∞‚†ü‚†ä‚£†‚†Ç ‚°∏
  ‚¢ª‚£ø‚£ø‚£∑‚£¶‚£Ä                 ‚£†‚¢ß‚°ô‚†∫‚†ø‚°á ‚†ò‚†á  ‚¢∏‚£ß  ‚¢†‚†É‚£æ‚£å‚†â‚†©‚†≠‚†ç‚£â‚°á
   ‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£Ä            ‚£†‚£û‚£ã ‚†à ‚°≥‚£ß     ‚¢∏‚°è  ‚°û‚¢∞‚†â‚†â‚†â‚†â‚†â‚†ì‚¢ª‚†É
    ‚†π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ñ  ‚¢Ä‚£Ä‚††‚†§‚£§‚£§‚†§‚†û‚†ì‚¢†‚†à‚°Ü ‚¢£‚£∏‚£æ‚†Ü     ‚¢Ä‚£Ä‚°º‚†Å‚°ø‚†à‚£â‚£â‚£í‚°í‚†¢‚°º 
     ‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£é‚£Ω‚£∂‚£§‚°∂‚¢ã‚£§‚†É‚£†‚°¶‚¢Ä‚°º‚¢¶‚£æ‚°§‚†ö‚£ü‚£Å‚£Ä‚£Ä‚£Ä‚£Ä ‚£Ä‚£à‚£Ä‚£†‚£æ‚£Ö ‚†ë‚†Ç‚†§‚†å‚£©‚°á 
      ‚†ò‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Å‚£∫‚¢Å‚£û‚£â‚°¥‚†ü‚°Ä   ‚†Å‚†∏‚°Ö ‚†à‚¢∑‚†à‚†è‚†ô ‚¢π‚°õ ‚¢â   ‚£Ä‚£Ä‚£º‚°á 
        ‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ω‚£ø‚°ü‚¢°‚†ñ‚£°‚°¥‚†Ç‚£Ä‚£Ä‚£Ä‚£∞‚£Å‚£Ä‚£Ä‚£∏    ‚†à‚†Å  ‚†à ‚£†‚†ú‚†ã‚£†‚†Å 
           ‚†ô‚¢ø‚£ø‚£ø‚£ø‚°ü‚¢ø‚£ø‚£ø‚£∑‚°ü‚¢ã‚£•‚£ñ‚£â ‚†à‚¢Å‚°Ä‚†§‚†ö‚†ø‚£∑‚°¶‚¢Ä‚£†‚£Ä‚†¢‚£Ñ‚£Ä‚°†‚†î‚†ã‚†Å ‚£º‚†É  
             ‚†à‚†ª‚£ø‚£ø‚°Ñ‚†à‚†ª‚£ø‚£ø‚¢ø‚£õ‚£©‚†§‚†í‚†â‚†Å     ‚†â‚†í‚¢§‚°Ä‚†â‚†Å     ‚¢Ä‚°ø   
               ‚†à‚†ô‚¢ø‚£§‚£§‚†¥‚†ü‚†ã‚†â             ‚†à‚†ë‚†§     ‚¢©‚†á   
                  ‚†à                               


**/
const { cmd } = require('../command');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Track pending replies per chat
const pendingQuality = new Map();

cmd({
  pattern: "xvideo",
  alias: ["xv", "xvideos"],
  react: "üîû",
  desc: "Search Xvideos & download (choose quality reply)",
  category: "fun",
  use: ".xvideo <search term>",
  filename: __filename
}, async (conn, mek, m, { text }) => {
  try {
    if (!text) return m.reply("üîç Please enter a search term!");

    // üîé Search API
    const search = await axios.get(`https://api.nekolabs.my.id/discovery/xvideos/search?q=${encodeURIComponent(text)}`);
    if (!search.data.success || !search.data.result?.length) return m.reply("‚ö†Ô∏è No results found!");

    const video = search.data.result[0];
    const { title, artist, duration, cover, url } = video;

    // üß© Downloader API
    const dl = await axios.get(`https://api.nekolabs.my.id/downloader/xvideos?url=${encodeURIComponent(url)}`);
    if (!dl.data.success) return m.reply("‚ö†Ô∏è Error fetching video!");

    const vids = dl.data.result.videos;
    const availableKeys = Object.keys(vids); // low, high, HLS
    if (availableKeys.length === 0) return m.reply("‚ö†Ô∏è No downloadable video found!");

    // Send thumbnail + options
    let menu = `üé¨ *${title}*\n‚è± Duration: ${duration}\n\nReply with number to choose quality:\n`;
    availableKeys.forEach((k, i) => {
      let label = k === 'low' ? '360p (Low)' : k === 'high' ? '720p/1080p (High)' : 'HLS (Stream)';
      menu += `${i + 1}Ô∏è‚É£ ${label}\n`;
    });

    const msg = await conn.sendMessage(m.chat, { image: { url: cover }, caption: menu }, { quoted: mek });

    // Store pending
    pendingQuality.set(m.chat, {
      vids,
      keys: availableKeys,
      msgId: msg.key.id,
      title
    });

    // Auto delete after 30s
    setTimeout(() => pendingQuality.delete(m.chat), 30000);

  } catch (e) {
    console.log(e);
    m.reply("‚ö†Ô∏è Something went wrong! üò¢");
  }
});

// ===================
// Global reply listener
// ===================
conn.ev.on("messages.upsert", async (update) => {
  try {
    const msg = update?.messages?.[0];
    if (!msg?.message) return;

    const text = msg.message.conversation?.trim();
    const chatId = msg.key.remoteJid;

    if (!pendingQuality.has(chatId)) return;
    const pending = pendingQuality.get(chatId);

    // Check reply is to the correct message
    const isReply = msg.message.extendedTextMessage?.contextInfo?.stanzaId === pending.msgId;
    if (!isReply) return;

    const index = parseInt(text) - 1;
    if (isNaN(index) || index < 0 || index >= pending.keys.length) {
      return conn.sendMessage(chatId, { text: "‚ùå Invalid number. Reply 1/2/3." }, { quoted: msg });
    }

    const key = pending.keys[index];
    let url = pending.vids[key];
    pendingQuality.delete(chatId);

    if (key.toLowerCase() === 'hls' || url.endsWith('.m3u8')) {
      // HLS sent as link
      return conn.sendMessage(chatId, { text: `üîó Stream link (${key}):\n${url}` }, { quoted: msg });
    }

    // Download video
    const tmpFile = path.join(__dirname, `temp_${Date.now()}.mp4`);
    const writer = fs.createWriteStream(tmpFile);
    const response = await axios({ url, method: 'GET', responseType: 'stream' });
    response.data.pipe(writer);

    await new Promise((resolve, reject) => {
      writer.on('finish', resolve);
      writer.on('error', reject);
    });

    // Send video
    await conn.sendMessage(chatId, {
      video: { url: tmpFile },
      caption: `‚úÖ Download ready (${key})\n*${pending.title}*`
    }, { quoted: msg });

    fs.unlinkSync(tmpFile);

  } catch (e) {
    console.log("Reply handler error", e);
  }
});
